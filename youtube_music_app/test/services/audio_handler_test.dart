import 'package:audio_service/audio_service.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:youtube_explode_dart/youtube_explode_dart.dart';
import 'package:youtube_music_app/models/track.dart';
import 'package:youtube_music_app/services/audio_handler.dart';

import 'audio_handler_test.mocks.dart'; // Generated by mockito

@GenerateMocks([AudioPlayer, YoutubeExplode, StreamManifest])
void main() {
  group('MyAudioHandler', () {
    late MyAudioHandler audioHandler;
    late MockAudioPlayer mockAudioPlayer;
    late MockYoutubeExplode mockYoutubeExplode;
    // Removed MockVideosClient and MockStreamsClient as they are not directly mocked
    late MockStreamManifest mockStreamManifest;

    setUp(() {
      mockAudioPlayer = MockAudioPlayer();
      mockYoutubeExplode = MockYoutubeExplode();
      mockStreamManifest = MockStreamManifest();

      // Configure YoutubeExplode mocks
      // We don't need to mock VideosClient and StreamsClient directly,
      // as we can mock the behavior of mockYoutubeExplode.videos.streamsClient.getManifest directly.
      when(mockYoutubeExplode.videos.streamsClient.getManifest(any))
          .thenAnswer((_) async => mockStreamManifest);
      
      // Configure AudioPlayer mocks
      when(mockAudioPlayer.onPlayerStateChanged).thenAnswer((_) => Stream.empty());
      when(mockAudioPlayer.onPositionChanged).thenAnswer((_) => Stream.empty());
      when(mockAudioPlayer.onPlayerComplete).thenAnswer((_) => Stream.empty());

      audioHandler = MyAudioHandler(
        audioPlayer: mockAudioPlayer,
        youtubeExplode: mockYoutubeExplode,
      );
    });

    // Helper to create a basic Track and MediaItem
    Track createTestTrack({String id = 'id', String title = 'title', String author = 'author', Duration? duration, String filePath = '', String thumbnailUrl = 'thumb'}) {
      return Track(
        id: id,
        title: title,
        author: author,
        duration: duration ?? Duration.zero,
        filePath: filePath,
        thumbnailUrl: thumbnailUrl,
      );
    }

    MediaItem createTestMediaItem({String id = 'id', String title = 'title', String author = 'author', Duration? duration, bool isLocal = false}) {
      return MediaItem(
        id: id,
        title: title,
        artist: author,
        duration: duration ?? Duration.zero,
        artUri: Uri.parse('thumb'),
        extras: {'is_local_file': isLocal},
      );
    }

    test('playMediaItem plays a local file', () async {
      // Arrange
      final mediaItem = createTestMediaItem(id: '/path/to/local.mp3', isLocal: true);

      // Act
      await audioHandler.playMediaItem(mediaItem);

      // Assert
      verify(mockAudioPlayer.setSourceDeviceFile('/path/to/local.mp3')).called(1);
      verify(mockAudioPlayer.resume()).called(1);
    });

    test('playMediaItem plays a remote stream', () async {
      // Arrange
      final mediaItem = createTestMediaItem(id: 'youtubeVideoId', isLocal: false);
      final mockStreamInfo = AudioOnlyStreamInfo(
        url: Uri.parse('streamUrl'),
        container: StreamContainer.webm,
        size: FileSize(100),
        audioCodec: AudioCodec.opus,
        bitrate: Bitrate(100),
      );

      when(mockStreamManifest.audioOnly.withHighestBitrate()).thenReturn(mockStreamInfo);

      // Act
      await audioHandler.playMediaItem(mediaItem);

      // Assert
      verify(mockYoutubeExplode.videos.streamsClient.getManifest(VideoId('youtubeVideoId'))).called(1);
      verify(mockAudioPlayer.setSourceUrl('streamUrl')).called(1);
      verify(mockAudioPlayer.resume()).called(1);
    });

    test('playRemoteTrack calls playMediaItem with correct data', () async {
      // Arrange
      final track = createTestTrack(id: 'remoteId', filePath: '');

      // Act
      audioHandler.playRemoteTrack(track); // Method is void, no await needed

      // Assert
      final captured = verify(mockYoutubeExplode.videos.streamsClient.getManifest(captureAny)).captured.first as VideoId;
      expect(captured.value, 'remoteId');
      // Verify playMediaItem is called (indirectly, via its mocked dependencies)
      verify(mockYoutubeExplode.videos.streamsClient.getManifest(any)).called(1);
    });

    test('playLocalTrack calls playMediaItem with correct data', () async {
      // Arrange
      final track = createTestTrack(id: 'localId', filePath: '/path/to/local.mp3');

      // Act
      audioHandler.playLocalTrack(track); // Method is void, no await needed

      // Assert
      verify(mockAudioPlayer.setSourceDeviceFile('/path/to/local.mp3')).called(1);
    });

    test('pause calls audioPlayer.pause', () async {
      await audioHandler.pause();
      verify(mockAudioPlayer.pause()).called(1);
    });

    test('play calls audioPlayer.resume', () async {
      await audioHandler.play();
      verify(mockAudioPlayer.resume()).called(1);
    });

    test('stop calls audioPlayer.stop and super.stop', () async {
      await audioHandler.stop();
      verify(mockAudioPlayer.stop()).called(1);
      // Mockito doesn't directly verify super calls, so this is a conceptual check.
    });

    test('seek calls audioPlayer.seek', () async {
      final position = Duration(seconds: 50);
      await audioHandler.seek(position);
      verify(mockAudioPlayer.seek(position)).called(1);
    });
    
    // Test Queue management
    test('addQueueItem adds item to queue and updates', () async {
      final mediaItem = createTestMediaItem();
      when(mockAudioPlayer.onPlayerStateChanged).thenAnswer((_) => Stream.empty()); // Prevent issues with state changes
      audioHandler = MyAudioHandler(
        audioPlayer: mockAudioPlayer,
        youtubeExplode: mockYoutubeExplode,
      ); // Reinitialize to reset queue
      await audioHandler.addQueueItem(mediaItem);
      expect(audioHandler.queue.value, contains(mediaItem));
    });

    test('addQueueItems adds multiple items to queue and updates', () async {
      final mediaItem1 = createTestMediaItem(id: 'id1');
      final mediaItem2 = createTestMediaItem(id: 'id2');
      when(mockAudioPlayer.onPlayerStateChanged).thenAnswer((_) => Stream.empty()); // Prevent issues with state changes
      audioHandler = MyAudioHandler(
        audioPlayer: mockAudioPlayer,
        youtubeExplode: mockYoutubeExplode,
      ); // Reinitialize to reset queue
      await audioHandler.addQueueItems([mediaItem1, mediaItem2]);
      expect(audioHandler.queue.value, containsAll([mediaItem1, mediaItem2]));
    });

    test('skipToNext plays next item in queue', () async {
      final mediaItem1 = createTestMediaItem(id: 'id1', isLocal: true);
      final mediaItem2 = createTestMediaItem(id: 'id2', isLocal: true);
      when(mockAudioPlayer.onPlayerStateChanged).thenAnswer((_) => Stream.empty());
      audioHandler = MyAudioHandler(
        audioPlayer: mockAudioPlayer,
        youtubeExplode: mockYoutubeExplode,
      );
      await audioHandler.addQueueItems([mediaItem1, mediaItem2]);
      await audioHandler.skipToQueueItem(0); // Play first item

      clearInteractions(mockAudioPlayer); // Clear previous interactions

      await audioHandler.skipToNext();
      verify(mockAudioPlayer.setSourceDeviceFile(mediaItem2.id)).called(1);
      verify(mockAudioPlayer.resume()).called(1);
      expect(audioHandler.mediaItem.value, mediaItem2);
    });

    test('skipToPrevious plays previous item in queue', () async {
      final mediaItem1 = createTestMediaItem(id: 'id1', isLocal: true);
      final mediaItem2 = createTestMediaItem(id: 'id2', isLocal: true);
      when(mockAudioPlayer.onPlayerStateChanged).thenAnswer((_) => Stream.empty());
      audioHandler = MyAudioHandler(
        audioPlayer: mockAudioPlayer,
        youtubeExplode: mockYoutubeExplode,
      );
      await audioHandler.addQueueItems([mediaItem1, mediaItem2]);
      await audioHandler.skipToQueueItem(1); // Play second item

      clearInteractions(mockAudioPlayer); // Clear previous interactions

      await audioHandler.skipToPrevious();
      verify(mockAudioPlayer.setSourceDeviceFile(mediaItem1.id)).called(1);
      verify(mockAudioPlayer.resume()).called(1);
      expect(audioHandler.mediaItem.value, mediaItem1);
    });
    
    test('skipToQueueItem plays specified item', () async {
      final mediaItem1 = createTestMediaItem(id: 'id1', isLocal: true);
      final mediaItem2 = createTestMediaItem(id: 'id2', isLocal: true);
      when(mockAudioPlayer.onPlayerStateChanged).thenAnswer((_) => Stream.empty());
      audioHandler = MyAudioHandler(
        audioPlayer: mockAudioPlayer,
        youtubeExplode: mockYoutubeExplode,
      );
      await audioHandler.addQueueItems([mediaItem1, mediaItem2]);
      clearInteractions(mockAudioPlayer); // Clear previous interactions

      await audioHandler.skipToQueueItem(1); // Play second item
      verify(mockAudioPlayer.setSourceDeviceFile(mediaItem2.id)).called(1);
      verify(mockAudioPlayer.resume()).called(1);
      expect(audioHandler.mediaItem.value, mediaItem2);
    });

    test('error during remote playback calls stop', () async {
      // Arrange
      final mediaItem = createTestMediaItem(id: 'youtubeVideoId', isLocal: false);

      when(mockStreamsClient.getManifest(VideoId('youtubeVideoId')))
          .thenThrow(Exception('Manifest error'));

      // Act
      await audioHandler.playMediaItem(mediaItem);

      // Assert
      verify(mockAudioPlayer.stop()).called(1);
      expect(audioHandler.playbackState.value.playing, isFalse);
    });

    test('onPlayerComplete plays next track if playing', () async {
      final mediaItem1 = createTestMediaItem(id: 'id1', isLocal: true);
      final mediaItem2 = createTestMediaItem(id: 'id2', isLocal: true);
      // Simulate player state changed to playing
      when(mockAudioPlayer.onPlayerStateChanged).thenAnswer((_) => Stream.value(PlayerState.playing));
      when(mockAudioPlayer.onPlayerComplete).thenAnswer((_) => Stream.value(PlayerState.completed)); // Simulate completion

      audioHandler = MyAudioHandler(
        audioPlayer: mockAudioPlayer,
        youtubeExplode: mockYoutubeExplode,
      );
      await audioHandler.addQueueItems([mediaItem1, mediaItem2]);
      await audioHandler.skipToQueueItem(0); // Play first item

      clearInteractions(mockAudioPlayer); // Clear previous interactions

      // Simulate player complete event
      await mockAudioPlayer.onPlayerComplete.first;

      // Assert that skipToNext was called, which in turn calls setSourceDeviceFile for mediaItem2
      verify(mockAudioPlayer.setSourceDeviceFile(mediaItem2.id)).called(1);
    });
  });
}