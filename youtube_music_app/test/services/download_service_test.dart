import 'dart:io';
import 'package:flutter_test/flutter_test.dart';
import 'package:http/http.dart' as http;
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:path_provider/path_provider.dart'; // For getApplicationDocumentsDirectory
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart'; // For mocking getApplicationDocumentsDirectory
import 'package:plugin_platform_interface/plugin_platform_interface.dart'; // For mocking
import 'package:youtube_explode_dart/youtube_explode_dart.dart';
import 'package:youtube_music_app/services/download_service.dart';
import 'package:collection/collection.dart'; // For UnmodifiableListView

import 'download_service_test.mocks.dart'; // Generated by mockito

// Mock PathProviderPlatform
class MockPathProviderPlatform extends Mock
    with MockPlatformInterfaceMixin
    implements PathProviderPlatform {
  @override
  Future<String?> getApplicationDocumentsPath() async {
    return 'test/path/documents';
  }

  @override
  Future<String?> getTemporaryPath() async => null;
  @override
  Future<String?> getApplicationSupportPath() async => null;
  @override
  Future<String?> getDownloadsPath() async => 'test/path/downloads'; // Mock downloads directory
  @override
  Future<String?> getLibraryPath() async => null;
  @override
  Future<List<String>?> getExternalCachePaths() async => null;
  @override
  Future<List<String>?> getExternalStoragePaths({StorageDirectory? type}) async => null;
}

// Mock http.Client
class MockHttpClient extends Mock implements http.Client {}

// Mock http.Response
class MockHttpResponse extends Mock implements http.Response {}

// Mock http.StreamedResponse
class MockStreamedResponse extends Mock implements http.StreamedResponse {}

// Mock Stream<List<int>>
class MockStreamByte extends Mock implements Stream<List<int>> {}

// Mock IOSink
class MockIOSink extends Mock implements IOSink {}

@GenerateMocks([
  YoutubeExplode, 
  StreamManifest, 
  MuxedStreamInfo, 
  // Removed VideosClient and StreamsClient from @GenerateMocks
])
void main() {
  group('DownloadService', () {
    late DownloadService downloadService;
    late MockYoutubeExplode mockYoutubeExplode;
    late MockHttpClient mockHttpClient;
    // Removed MockVideosClient and MockStreamsClient declarations
    late MockStreamManifest mockStreamManifest;
    late MockMuxedStreamInfo mockMuxedStreamInfo;

    setUp(() {
      // Mock getApplicationDocumentsDirectory
      PathProviderPlatform.instance = MockPathProviderPlatform();

      mockYoutubeExplode = MockYoutubeExplode();
      mockHttpClient = MockHttpClient();
      mockStreamManifest = MockStreamManifest();
      mockMuxedStreamInfo = MockMuxedStreamInfo();

      // Configure mockMuxedStreamInfo properties
      when(mockMuxedStreamInfo.url).thenReturn(Uri.parse('testUrl'));
      when(mockMuxedStreamInfo.container).thenReturn(StreamContainer.mp4);
      when(mockMuxedStreamInfo.size).thenReturn(FileSize(10 * 1024 * 1024)); // 10MB
      when(mockMuxedStreamInfo.bitrate).thenReturn(Bitrate(1000));
      when(mockMuxedStreamInfo.videoQuality).thenReturn(VideoQuality.hd720); 
      when(mockMuxedStreamInfo.videoResolution).thenReturn(VideoResolution(1280, 777)); 
      when(mockMuxedStreamInfo.videoCodec).thenReturn(VideoCodec.avc1); 
      when(mockMuxedStreamInfo.audioCodec).thenReturn(AudioCodec.aac); 
      when(mockMuxedStreamInfo.framerate).thenReturn(30);
      when(mockMuxedStreamInfo.isLive).thenReturn(false);

      // Stub mockStreamManifest.muxed
      when(mockStreamManifest.muxed).thenReturn(UnmodifiableListView([mockMuxedStreamInfo]));

      // Mock the behavior of mockYoutubeExplode.videos.streamsClient.getManifest
      // This is a more direct way to mock the chain of calls if inner clients are not mockable.
      when(mockYoutubeExplode.videos).thenAnswer((_) {
        final videosClientMock = MockVideosClient(); // Manually create a mock for VideosClient
        when(videosClientMock.streamsClient).thenAnswer((_) {
          final streamsClientMock = MockStreamsClient(); // Manually create a mock for StreamsClient
          when(streamsClientMock.getManifest(any)).thenAnswer((_) async => mockStreamManifest);
          return streamsClientMock;
        });
        return videosClientMock;
      });

      // Instantiate DownloadService AFTER all its dependencies are mocked
      downloadService = DownloadService(
        youtubeExplode: mockYoutubeExplode,
        httpClient: mockHttpClient,
      );
    });

    test('downloadAudio downloads a muxed stream successfully', () async {
      // Arrange
      final video = Video(
        VideoId('testVideoId'),
        'Test Title',
        'Test Author',
        ChannelId('testChannelId'), 
        DateTime.now(), 
        null, 
        null, 
        'Description',
        Duration(seconds: 30),
        ThumbnailSet('testVideoId'),
        ['keyword1', 'keyword2'], 
        Engagement(0, 0, 0), 
        false, 
      );
      
      final mockStreamedResponse = MockStreamedResponse();

      when(mockHttpClient.send(any as http.BaseRequest)).thenAnswer((_) async => mockStreamedResponse);
      when(mockStreamedResponse.stream).thenAnswer((_) => http.ByteStream(Stream.fromIterable([ 
            List.filled(5 * 1024 * 1024, 0), 
            List.filled(5 * 1024 * 1024, 0), 
          ])));
      when(mockStreamedResponse.contentLength).thenReturn(10 * 1024 * 1024); // 10MB
      when(mockStreamedResponse.statusCode).thenReturn(200);

      // Act
      final result = await downloadService.downloadAudio(
        video,
        onProgress: (progress) {},
      );

      // Assert
      expect(result, 'test/path/downloads/testVideoId.mp4');
      // Update verify calls to reflect the new mocking structure
      verify(mockYoutubeExplode.videos.streamsClient.getManifest(video.id)).called(1);
      verify(mockHttpClient.send(any as http.BaseRequest)).called(1);
    });

    test('downloadAudio retries on error', () async {
      // Arrange
      final video = Video(
        VideoId('testVideoId'),
        'Test Title',
        'Test Author',
        ChannelId('testChannelId'), 
        DateTime.now(), 
        null, 
        null, 
        'Description',
        Duration(seconds: 30),
        ThumbnailSet('testVideoId'),
        ['keyword1', 'keyword2'], 
        Engagement(0, 0, 0), 
        false, 
      );

      // Simulate network error on first two attempts
      when(mockHttpClient.send(any as http.BaseRequest))
          .thenAnswer((_) async => throw http.ClientException('Connection closed'));
      when(mockHttpClient.send(any as http.BaseRequest))
          .thenAnswer((_) async => throw http.ClientException('Connection closed'));
      when(mockHttpClient.send(any as http.BaseRequest))
          .thenAnswer((_) async {
        final mockStreamedResponse = MockStreamedResponse();
        when(mockStreamedResponse.stream).thenAnswer((_) => http.ByteStream(Stream.fromIterable([List.filled(10, 0)]))); 
        when(mockStreamedResponse.contentLength).thenReturn(10);
        when(mockStreamedResponse.statusCode).thenReturn(200);
        return mockStreamedResponse;
      });

      // Act
      final result = await downloadService.downloadAudio(
        video,
        onProgress: (progress) {},
      );

      // Assert
      expect(result, 'test/path/downloads/testVideoId.mp4');
      verify(mockYoutubeExplode.videos.streamsClient.getManifest(video.id)).called(3); 
      verify(mockHttpClient.send(any as http.BaseRequest)).called(3);
    });

    test('downloadAudio throws exception after max retries', () async {
      // Arrange
      final video = Video(
        VideoId('testVideoId'),
        'Test Title',
        'Test Author',
        ChannelId('testChannelId'), 
        DateTime.now(), 
        null, 
        null, 
        'Description',
        Duration(seconds: 30),
        ThumbnailSet('testVideoId'),
        ['keyword1', 'keyword2'], 
        Engagement(0, 0, 0), 
        false, 
      );

      // Simulate network error on all three attempts
      when(mockHttpClient.send(any as http.BaseRequest))
          .thenAnswer((_) async => throw http.ClientException('Connection closed')); 

      // Act & Assert
      await expectLater(
        downloadService.downloadAudio(video, onProgress: (progress) {}),
        throwsA(isA<Exception>()),
      );
      verify(mockYoutubeExplode.videos.streamsClient.getManifest(video.id)).called(3); 
      verify(mockHttpClient.send(any as http.BaseRequest)).called(3);
    });

    test('downloadAudio throws exception if no muxed stream found', () async {
      // Arrange
      final video = Video(
        VideoId('testVideoId'),
        'Test Title',
        'Test Author',
        ChannelId('testChannelId'), 
        DateTime.now(), 
        null, 
        null, 
        'Description',
        Duration(seconds: 30),
        ThumbnailSet('testVideoId'),
        ['keyword1', 'keyword2'], 
        Engagement(0, 0, 0), 
        false, 
      );
      when(mockStreamManifest.muxed).thenReturn(UnmodifiableListView([])); // No muxed streams

      // Act & Assert
      await expectLater(
        downloadService.downloadAudio(video, onProgress: (progress) {}),
        throwsA(isA<Exception>()),
      );
      verify(mockYoutubeExplode.videos.streamsClient.getManifest(video.id)).called(1);
      verifyNever(mockHttpClient.send(any as http.BaseRequest)); // No download attempt
    });
  });
}

// Manually create mock classes for VideosClient and StreamsClient
// as mockito:mockBuilder cannot generate them directly.
class MockVideosClient extends Mock implements VideosClient {}
class MockStreamsClient extends Mock implements StreamsClient {}
